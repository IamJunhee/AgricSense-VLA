<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VLA 데이터 수집 및 모니터링</title>
    <style>
        /* box-sizing 전체 적용으로 너비 계산 방식 변경 */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        /* 전체 페이지 스타일 */
        body {
            font-family: 'Malgun Gothic', '맑은 고딕', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 전체 컨테이너 */
        .container {
            width: 100%;
            max-width: 1200px;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* 상단 이미지 영역 */
        .image-placeholder {
            width: 100%;
            min-height: 300px; /* 최소 높이 유지, 이미지가 로드되면 크기 조절됨 */
            background-color: #e9ecef;
            border: 2px dashed #ced4da;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #6c757d;
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 15px; 
            position: relative; 
            cursor: crosshair; 
        }
        .image-placeholder img { /* RGB 이미지 스타일 */
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 6px;
        }
        .depth-info { /* Depth 값 표시 스타일 */
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            display: none; /* 기본적으로 숨김 */
        }


        /* 질문과 입력 필드를 감싸는 행 */
        .input-row {
            display: flex; 
            align-items: stretch; 
            margin-bottom: 20px; 
            gap: 20px; 
        }

        /* 질문 영역 스타일 */
        .question-area {
            flex: 1; 
            padding: 12px;
            border: 1px solid #e0e0e0; 
            border-radius: 6px;
            background-color: #f8f9fa; 
            color: #343a40;
            font-size: 1em;
            min-height: 80px; 
            display: flex; 
            align-items: flex-start; 
            /* word-break: keep-all; */ /* 일단 주석 처리 또는 삭제 */
            overflow-wrap: break-word;
            line-height: 1.6;
            white-space: pre-wrap; /* 중요: \n 문자를 줄 바꿈으로 렌더링 */
        }

        /* 입력 필드 (textarea) 스타일 */
        .input-row textarea {
            flex: 1; 
            padding: 12px;
            border: 1px solid #ced4da; 
            border-radius: 6px; 
            font-size: 1em;
            font-family: inherit; 
            min-height: 80px; 
            resize: vertical; 
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; 
            overflow-y: hidden; 
        }

        .input-row textarea:focus {
            border-color: #007bff; 
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); 
            outline: none; 
        }
        .input-row textarea:disabled { /* 비활성화 시 스타일 */
            background-color: #e9ecef;
            cursor: not-allowed;
        }


        /* 실행 버튼 스타일 */
        .action-button {
            display: block; 
            width: fit-content; 
            padding: 12px 30px; 
            background-color: #007bff; 
            color: white; 
            border: none;
            border-radius: 6px; 
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer; 
            margin: 30px auto 0; 
            transition: background-color 0.2s ease-in-out; 
        }

        .action-button:hover {
            background-color: #0056b3; 
        }
        .action-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* 상태 표시줄 (선택 사항) */
        .status-bar {
            margin-top: 15px;
            padding: 10px;
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9em;
        }
        .status-bar.error {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }


        /* 모바일 반응형 스타일 */
        @media (max-width: 768px) { 
            .container {
                margin: 10px; 
                padding: 15px; 
            }
            .image-placeholder { min-height: 200px; font-size: 1.2em; }
            .input-row { flex-direction: column; gap: 10px; }
            .question-area { min-height: 60px; }
            .input-row textarea { width: 100%; min-height: 100px; }
            .action-button { width: 100%; padding: 15px; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="image-placeholder" id="imageDisplayArea">
            <span>RGB 이미지가 여기에 표시됩니다.</span>
            <div class="depth-info" id="depthInfo">Depth: - mm</div>
        </div>
        <canvas id="hiddenDepthCanvas" style="display:none;"></canvas> 
        <div class="input-row">
            <div class="question-area" id="question1">인지 프롬프트가 여기에 표시됩니다.</div>
            <textarea id="input1" name="input1" placeholder="인지 프롬프트에 대한 응답을 입력하세요..."></textarea>
        </div>

        <div class="input-row">
            <div class="question-area" id="question2">사고 프롬프트가 여기에 표시됩니다.</div>
            <textarea id="input2" name="input2" placeholder="사고 프롬프트에 대한 응답을 입력하세요..."></textarea>
        </div>

        <div class="input-row">
            <div class="question-area" id="question3">행동 프롬프트가 여기에 표시됩니다.</div>
            <textarea id="input3" name="input3" placeholder="행동 프롬프트에 대한 응답을 입력하세요..."></textarea>
        </div>

        <button class="action-button" id="executeButton">데이터 전송 (수집 모드)</button>
        <div class="status-bar" id="statusBar" style="display:none;">상태 메시지</div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM 요소 가져오기 ---
            const imageDisplayArea = document.getElementById('imageDisplayArea');
            const depthInfoDiv = document.getElementById('depthInfo');
            const hiddenDepthCanvas = document.getElementById('hiddenDepthCanvas');
            const depthCtx = hiddenDepthCanvas.getContext('2d', { willReadFrequently: true });


            const question1Div = document.getElementById('question1');
            const question2Div = document.getElementById('question2');
            const question3Div = document.getElementById('question3');

            const input1Textarea = document.getElementById('input1');
            const input2Textarea = document.getElementById('input2');
            const input3Textarea = document.getElementById('input3');
            const allTextareas = [input1Textarea, input2Textarea, input3Textarea];

            const executeButton = document.getElementById('executeButton');
            const statusBar = document.getElementById('statusBar');

            // --- 상태 변수 ---
            let websocket = null;
            let currentOperationMode = "data_collection"; // 기본값
            let currentSceneData = null; // 수신된 sceneData 저장 (특히 depthImage 정보)
            let rgbImageElement = null; // 동적으로 생성될 img 태그

            const WEBSOCKET_URL = "ws://localhost:9090"; // 실제 ROS2 웹소켓 서버 주소로 변경

            // --- 유틸리티 함수 ---
            function generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            function updateStatusBar(message, isError = false) {
                statusBar.textContent = message;
                statusBar.className = isError ? 'status-bar error' : 'status-bar';
                statusBar.style.display = 'block';
            }

            // --- 웹소켓 관련 함수 ---
            function connectWebSocket() {
                console.log("웹소켓 연결 시도:", WEBSOCKET_URL);
                updateStatusBar("서버에 연결 중...", false);
                websocket = new WebSocket(WEBSOCKET_URL);

                websocket.onopen = () => {
                    console.log("웹소켓 연결 성공!");
                    updateStatusBar("서버에 성공적으로 연결되었습니다.", false);
                };

                websocket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        console.log("메시지 수신:", message);
                        handleIncomingMessage(message);
                    } catch (e) {
                        console.error("수신 메시지 파싱 오류:", e);
                        updateStatusBar("수신된 메시지 형식이 올바르지 않습니다.", true);
                    }
                };

                websocket.onerror = (error) => {
                    console.error("웹소켓 오류:", error);
                    updateStatusBar("웹소켓 연결 오류 발생. 콘솔을 확인하세요.", true);
                };

                websocket.onclose = () => {
                    console.log("웹소켓 연결 종료.");
                    updateStatusBar("서버와의 연결이 끊어졌습니다. 재연결을 시도합니다...", true);
                    setTimeout(connectWebSocket, 5000); 
                };
            }

            function sendMessage(type, payload) {
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    const message = {
                        messageId: generateUUID(),
                        type: type,
                        timestamp: new Date().toISOString(),
                        source: "webpage",
                        payload: payload
                    };
                    console.log("메시지 발신:", message);
                    websocket.send(JSON.stringify(message));
                } else {
                    console.error("웹소켓이 연결되지 않았습니다. 메시지 발신 실패:", type);
                    updateStatusBar("서버에 연결되지 않아 메시지를 보낼 수 없습니다.", true);
                }
            }

            // --- 수신 메시지 처리 로직 ---
            function handleIncomingMessage(message) {
                if (!message.payload) {
                    console.warn("Payload가 없는 메시지 수신:", message);
                    return;
                }
                switch (message.type) {
                    case "setOperationMode":
                        handleSetOperationMode(message.payload);
                        break;
                    case "sceneData":
                        currentSceneData = message.payload; 
                        handleSceneData(message.payload);
                        break;
                    case "agentResponse":
                        handleAgentResponse(message.payload);
                        break;
                    case "statusNotification":
                        updateStatusBar(message.payload.message, message.payload.level === 'error');
                        break;
                    default:
                        console.warn("알 수 없는 메시지 타입 수신:", message.type);
                }
            }

            function handleSetOperationMode(payload) {
                currentOperationMode = payload.mode;
                console.log("운영 모드 변경:", currentOperationMode);
                updateStatusBar(`운영 모드가 ${currentOperationMode === 'data_collection' ? '데이터 수집' : '실행 모니터링'} 모드로 변경되었습니다.`, false);
                updateUIForMode();
            }

            function handleSceneData(payload) {
                if (payload.prompts) {
                    question1Div.textContent = payload.prompts.cognition || "인지 프롬프트 없음";
                    question2Div.textContent = payload.prompts.thinking || "사고 프롬프트 없음";
                    question3Div.textContent = payload.prompts.action || "행동 프롬프트 없음";
                }

                if (payload.vision && payload.vision.rgbImage && payload.vision.rgbImage.data && payload.vision.rgbImage.format) {
                    if (!rgbImageElement) {
                        rgbImageElement = document.createElement('img');
                        imageDisplayArea.innerHTML = ''; 
                        imageDisplayArea.appendChild(rgbImageElement);
                        imageDisplayArea.appendChild(depthInfoDiv); 
                    }
                    // 수정된 부분: RGB 이미지도 순수 Base64와 format을 받아 Data URI를 구성합니다.
                    rgbImageElement.src = `data:image/${payload.vision.rgbImage.format};base64,${payload.vision.rgbImage.data}`; 
                    rgbImageElement.alt = "RGB Scene Image";
                    depthInfoDiv.style.display = 'none'; 
                } else {
                    imageDisplayArea.innerHTML = '<span>RGB 이미지가 없습니다.</span>';
                    rgbImageElement = null;
                }
                allTextareas.forEach(ta => ta.value = '');
                adjustAllTextareasHeight(); 
                updateUIForMode(); 
            }

            function handleAgentResponse(payload) {
                if (currentOperationMode === "execution_monitoring") {
                    if (payload.responses) {
                        input1Textarea.value = payload.responses.cognition || "";
                        input2Textarea.value = payload.responses.thinking || "";
                        input3Textarea.value = payload.responses.action || "";
                        adjustAllTextareasHeight();
                    }
                } else {
                    console.warn("데이터 수집 모드에서 agentResponse 수신됨. 무시합니다.");
                }
            }

            // --- UI 업데이트 및 상호작용 ---
            function updateUIForMode() {
                if (currentOperationMode === "data_collection") {
                    allTextareas.forEach(ta => ta.disabled = false);
                    executeButton.disabled = false;
                    executeButton.textContent = "데이터 전송 (수집 모드)";
                } else if (currentOperationMode === "execution_monitoring") {
                    allTextareas.forEach(ta => ta.disabled = true);
                    executeButton.disabled = true; 
                    executeButton.textContent = "실행 모니터링 중";
                }
            }
            
            executeButton.addEventListener('click', () => {
                if (currentOperationMode === "data_collection") {
                    if (!currentSceneData || !currentSceneData.vision || !currentSceneData.vision.imageTimestamp) {
                        updateStatusBar("현재 유효한 장면 데이터가 없습니다. 데이터를 전송할 수 없습니다.", true);
                        return;
                    }
                    const userResponses = {
                        cognition: input1Textarea.value,
                        thinking: input2Textarea.value,
                        action: input3Textarea.value
                    };
                    const payload = {
                        responses: userResponses,
                        associatedImageTimestamp: currentSceneData.vision.imageTimestamp
                    };
                    sendMessage("userAnnotation", payload);
                    updateStatusBar("사용자 주석을 서버로 전송했습니다.", false);
                }
            });

            function adjustTextareaHeight(textarea) {
                textarea.style.height = 'auto';
                const computedStyle = window.getComputedStyle(textarea);
                const minHeight = parseInt(computedStyle.minHeight, 10) || 0;
                let newHeight = textarea.scrollHeight;
                if (newHeight < minHeight) newHeight = minHeight;
                textarea.style.height = newHeight + 'px';
            }

            function adjustAllTextareasHeight() {
                allTextareas.forEach(adjustTextareaHeight);
            }
            allTextareas.forEach(textarea => {
                textarea.addEventListener('input', () => adjustTextareaHeight(textarea));
            });
            window.addEventListener('resize', adjustAllTextareasHeight);


            // --- 클라이언트 측 Depth 값 계산 ---
            imageDisplayArea.addEventListener('click', (event) => {
                if (!rgbImageElement || !currentSceneData || !currentSceneData.vision || !currentSceneData.vision.depthImage) {
                    console.log("Depth 계산을 위한 RGB 또는 Depth 이미지가 없습니다.");
                    depthInfoDiv.style.display = 'block';
                    depthInfoDiv.textContent = "Depth: 정보 없음";
                    return;
                }

                const depthPayload = currentSceneData.vision.depthImage;
                if (!depthPayload.data || !depthPayload.format) { 
                    console.log("Depth 이미지 데이터 또는 포맷 정보가 없습니다.");
                    depthInfoDiv.style.display = 'block';
                    depthInfoDiv.textContent = "Depth: 데이터/포맷 없음";
                    return;
                }

                const rect = rgbImageElement.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;

                const scaleX = rgbImageElement.naturalWidth / rgbImageElement.width;
                const scaleY = rgbImageElement.naturalHeight / rgbImageElement.height;

                const originalX = Math.floor(clickX * scaleX);
                const originalY = Math.floor(clickY * scaleY);

                if (originalX < 0 || originalX >= depthPayload.width || originalY < 0 || originalY >= depthPayload.height) {
                    console.log("클릭 좌표가 이미지 범위를 벗어났습니다.");
                    depthInfoDiv.style.display = 'none';
                    return;
                }

                const depthImage = new Image();
                depthImage.onload = () => {
                    hiddenDepthCanvas.width = depthPayload.width; 
                    hiddenDepthCanvas.height = depthPayload.height;
                    depthCtx.drawImage(depthImage, 0, 0, depthPayload.width, depthPayload.height);

                    try {
                        const pixelData = depthCtx.getImageData(originalX, originalY, 1, 1).data;
                        let rawDepthValue = 0;

                        if (depthPayload.encoding === "16UC1" || depthPayload.encoding === "mono16" || (depthPayload.encoding && depthPayload.encoding.toLowerCase().includes("uint16")) ) {
                            const msb = pixelData[0]; // R 채널
                            const lsb = pixelData[1]; // G 채널
                            rawDepthValue = (msb << 8) | lsb;
                            console.log(`16UC1 Depth: MSB=${msb}, LSB=${lsb}, Raw=${rawDepthValue}`);
                        } else if (depthPayload.encoding === "8UC1" || depthPayload.encoding === "mono8" || (depthPayload.encoding && depthPayload.encoding.toLowerCase().includes("uint8"))) {
                            rawDepthValue = pixelData[0]; 
                             console.log(`8UC1 Depth: Raw=${rawDepthValue}`);
                        }
                        else {
                            rawDepthValue = pixelData[0]; 
                            console.warn(`알 수 없는 Depth 인코딩 (${depthPayload.encoding}), R 채널 값을 사용합니다. Raw=${rawDepthValue}`);
                        }
                        
                        const scaleFactor = parseFloat(depthPayload.scale) || 1.0;
                        const actualDepth = rawDepthValue * scaleFactor;
                        
                        depthInfoDiv.textContent = `Depth: ${actualDepth.toFixed(2)} ${depthPayload.unit || 'units'} (at ${originalX},${originalY})`;
                        depthInfoDiv.style.display = 'block';

                    } catch (e) {
                        console.error("Depth 값 읽기 오류:", e);
                        depthInfoDiv.textContent = "Depth: 오류";
                        depthInfoDiv.style.display = 'block';
                    }
                };
                depthImage.onerror = () => {
                    console.error("Depth 이미지 로드 실패");
                    depthInfoDiv.textContent = "Depth: 이미지 로드 실패";
                    depthInfoDiv.style.display = 'block';
                }
                depthImage.src = `data:image/${depthPayload.format};base64,${depthPayload.data}`;
            });

            connectWebSocket(); 
            adjustAllTextareasHeight(); 
            updateUIForMode(); 
        });
    </script>

</body>
</html>
